function rotate(object, axis, radians) {
    rotObjectMatrix = new THREE.Matrix4(), rotObjectMatrix.makeRotationAxis(axis.normalize(), radians), 
    object.matrix.multiply(rotObjectMatrix), object.rotation.setFromRotationMatrix(object.matrix);
}

function render() {
    window.requestAnimationFrame(render), b.addForce(mousePos.normalize()), b.flap(), 
    b.update(), renderer.render(scene, camera);
}

function distance(vec1, vec2) {
    return vec1.distanceTo(vec2);
}

var WIDTH = window.innerWidth, HEIGHT = window.innerHeight, renderer = new THREE.WebGLRenderer();

renderer.setClearColor(16777215, 1);

var scene = new THREE.Scene();

camera = new THREE.PerspectiveCamera(20, window.innerWidth / window.innerHeight, 1, 1e4), 
camera.position.z = 800, renderer.setSize(window.innerWidth, window.innerHeight), 
document.getElementsByTagName("body")[0].appendChild(renderer.domElement);

var mousePos = new THREE.Vector2();

window.addEventListener("mousemove", function(e) {
    mousePos.x = e.clientX - window.innerWidth / 2, mousePos.y = e.clientY - window.innerHeight / 2, 
    mousePos.y *= -1;
}), window.addEventListener("onresize", function() {
    WIDTH = window.innerWidth, HEIGHT = window.innerHeight;
});

var b = new Boid();

scene.add(b.mesh), render();

var TriMesh = function(width, height) {
    width = void 0 !== width ? width : 200, height = void 0 != height ? height : 100;
    var geo = new THREE.Geometry(), a = new THREE.Vector3(0, 0, 0), b = new THREE.Vector3(width, 0, 0), c = new THREE.Vector3(height, height, 0);
    geo.vertices.push(a), geo.vertices.push(b), geo.vertices.push(c), geo.faces.push(new THREE.Face3(0, 1, 2));
    var mat = new THREE.MeshBasicMaterial({
        color: 15658734 * Math.random()
    }), mesh = new THREE.Mesh(geo, mat);
    mesh.material.side = THREE.DoubleSide, this.mesh = mesh, this.geo = geo, this.vertices = [ a, b, c ], 
    this.setCenterRotation(width, height);
};

TriMesh.prototype = {
    getMesh: function() {
        return this.mesh;
    },
    setCenterRotation: function(width) {
        this.geo.applyMatrix(new THREE.Matrix4().makeTranslation(width / 2, 0, 0));
    },
    setMaterial: function() {},
    rotate: function(amt) {
        this.mesh.rotation.x = .5 * Math.cos(amt);
    }
}, THREE.Mesh.rotate = function(axis, radians) {
    var rotationMatrix = new THREE.Matrix4();
    rotationMatrix.makeRotationAxis(axis.normalize(), radians), rotationMatrix.multiply(this.matrix), 
    this.matrix = rotationMatrix, this.rotation.setFromRotationMatrix(this.matrix);
};

var Boid = function() {
    var left = new TriMesh(20, 20), right = new TriMesh(20, 20);
    this.left = left.mesh, this.right = right.mesh, this.mesh = new THREE.Object3D(), 
    this.mesh.add(left.mesh), this.mesh.add(right.mesh), this.position = this.mesh.position, 
    this.acceleration = new THREE.Vector3(), this.velocity = new THREE.Vector3(), this.flapSpeed = 2, 
    this.mass = 10, this.maxspeed = 5, this.angle = 0, this.neighbors = [];
};

Boid.prototype = {
    addForce: function(force) {
        var z = 0;
        force.hasOwnProperty("z") && (z = force.z);
        var v = new THREE.Vector3(force.x, force.y, z);
        v.divideScalar(this.mass), this.acceleration.add(v);
    },
    update: function() {
        this.velocity.add(this.acceleration), this.position.add(this.velocity), this.mesh.position = this.position, 
        this.acceleration.multiplyScalar(0);
    },
    addToScene: function(scene) {
        scene.add(this.obj);
    },
    flap: function() {
        this._flapLeft(.5), this._flapRight(.5);
    },
    getLeft: function() {
        return left.mesh;
    },
    getRight: function() {
        return right.mesh;
    },
    updateWings: function() {
        this._flapLeft(50), this._flapRight(-50);
    },
    getPosition: function() {
        return this.obj.position;
    },
    getVelocity: function() {
        return this.velocity;
    },
    checkBoundries: function() {
        this.position.x > WIDTH && (this.position.x = -WIDTH), this.position.x < -WIDTH && (this.position.x = WIDTH), 
        this.position.y > HEIGHT && (this.position.y = -HEIGHT), this.position.y < -HEIGHT && (this.position.y = HEIGHT), 
        this.position.z > _depth && (this.position.z = -_depth), this.position.z < -_depth && (this.position.z = _depth);
    },
    flock: function() {
        var seperate = this.seperate(), align = this.align(), cohesion = this.cohesion();
        this.addForce(seperate), this.addForce(align), this.addForce(cohesion);
    },
    seek: function(target) {
        var desired = target.sub(this.getPosition());
        desired.normalize(), desired.multiplyScalar(this.maxspeed);
        var steer = desired.sub(this.getVelocity());
        return steer;
    },
    seperate: function() {
        for (var desiredsep = 25, steer = new THREE.Vector3(), count = 0, i = 0; i < this.neighbors.length; ++i) {
            var neighbor = this.neighbors[i], d = distance(this.obj.position, neighbor.getPosition());
            if (d > 0 && desiredsep > d) {
                var diff = THREE.Vector3.subtract(this.object.position, neighbor.getPosition());
                diff.normalize(), diff.divideScalar(d), steer.add(diff), count++;
            }
        }
        return count > 0 && steer.divideScalar(count), steer.length() > 0 && (steer.normalize(), 
        steer.multiplyScalar(this.maxspeed), steer.limit(this.maxforce)), steer;
    },
    align: function() {
        for (var neighbordist = 40, sum = new THREE.Vector3(), count = 0, i = 0; i < this.getNumNeighbors(); ++i) {
            var neighbor = this.neighbors[i], d = distance(this.position, neighbor.getPosition());
            d > 0 && neighbordist > d && (sum.add(neighbor.getVelocity()), count++);
        }
        return count > 0 ? (sum.divideScalar(count), sum.normalize(), sum.multiplyScalar(maxspeed), 
        steer.limit(maxforce), steer) : new THREE.Vector3();
    },
    cohesion: function() {
        for (var neighbordist = 40, sum = new THREE.Vector3(), count = 0, i = 0; i < this.getNumNeighbors(); ++i) {
            var neighbor = this.neighbors[i], d = distance(this.position, neighrbor.getPosition());
            d > 0 && neighbordist > d && (sum.add(neighbor.getPosition()), count++);
        }
        return count > 0 ? (sum.divideScalar(count), this.seek(sum)) : new THREE.Vector3();
    },
    _flapLeft: function() {
        return this.angle += .05, this.left.rotation.x = Math.sin(this.angle) * this.flapSpeed, 
        this;
    },
    _flapRight: function() {
        return this.angle += .05, this.right.rotation.x = -(Math.sin(this.angle) * this.flapSpeed), 
        this;
    }
};

var Flock = function(scene) {
    this.scene = scene, this.boids = [], this.boidlen = 0;
};

Flock.prototype = {
    addBoid: function(num) {
        this.boidlen += num;
        for (var i = 0; num > i; ++i) this.boids.push(new Boid());
        this._prepare();
    },
    follow: function() {
        for (var i = 0; i < this.boidlen; ++i) {
            var boid = this.boids[i], dx = mousePos.x - boid.getPosition().x, dy = mousePos.y - boid.getPosition().y;
            boid.position.x += .05 * dx, boid.position.y += .05 * dy;
        }
    },
    flap: function() {
        for (var i = 0; i < this.boidlen; ++i) this.boids[i].updateWings();
    },
    _prepare: function() {
        for (var i = 0; i < this.boidlen; ++i) this.boids[i].addToScene(this.scene);
    },
    update: function() {},
    render: function(scene) {
        for (var i = 0; i < this.boidslen; ++i) scene.add(this.boids[i]);
    }
};